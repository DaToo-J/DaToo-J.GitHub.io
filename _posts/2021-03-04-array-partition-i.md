---
layout: single
classes: wide
toc: true
toc_label: "本文内容"
toc_icon: "list"
sidebar:
  nav: "main"
comments: true

tags: 双指针 数组
title: 561 数组拆分 I
excerpt: 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。
---

## 题目

> 题目链接：[561. 数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

示例 1：

    输入：nums = [1,4,3,2]
    输出：4
    解释：所有可能的分法（忽略元素顺序）为：
        1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
        2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
        3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
        所以最大总和为 4

示例 2：

    输入：nums = [6,2,6,5,1,2]
    输出：9
    解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9

提示：

    1 <= n <= 104
    nums.length == 2 * n
    -104 <= nums[i] <= 104

## 思路 

1. 如果希望 $min(ai, bi)$ 的总和最大，那么每一个 $min(ai, bi)$ 的值 $m_i$ 都尽可能大。但是 $m_i$ 又只能是 $ai, bi$ 中较小的那一个。
2. 因此，将数组按升序排序两两组成 $ai, bi$，然后求 $min(ai, bi)$ 总和才能保证和最大。
3. 🌰：
   1. `nums = [1,4,3,2]`
   2. 分法 1: `(1, 4), (2, 3)`
   3. 分法 2: `(1, 2), (3, 4)`
   4. 第一个分法就不如第二个分法“划算”，拜拜浪费了 `3`。因为第一个分法的结果：`1+2=3`，而第二个分法的结果：`1+3=4`。
   5. 或者这样想：`1` 是数组里最小的，无论哪个元素和它成组，它都会被选出来参与结果的计算。这个时候如果选 `4` 或 `3` 和它成组，显然是“不划算的”，因为这样分组  `4` 或 `3` 就不参与「和最大」的结果计算，因此，`1` 应该与 `2` 成组。而 `2` 此时是数组中除了 `1` 之外最小的元素。

4. 代码：
   1. 得到排序后的数组；
   2. 每个 $m_i$ 都是索引为偶数的那个元素，求和即可。

## 代码 

```python
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum([nums[i] for i in range(0, len(nums), 2)])
```


